---
title: "Webhooks"
description: "Receive consent lifecycle events from Emerge Link"
---

Use Link webhooks to track consent lifecycle changes per provider.

## Authentication

Webhook deliveries are signed with HMAC-SHA256. Verify every request before processing.

Headers sent by Emerge:

| Header | Description |
|--------|-------------|
| `X-Signature` | HMAC-SHA256 signature (hex) |
| `X-Webhook-Version` | Payload/header contract version (`2.0`) |
| `X-Attempt-Number` | Delivery attempt number (starts at `1`) |
| `Idempotency-Key` | Stable id for deduplication |

## Event types

| Event | Description |
|-------|-------------|
| `consent.given` | New consent granted |
| `consent.revoked` | Consent revoked |
| `consent.expiring` | Consent nearing expiry |
| `consent.reauthorized` | Previously revoked/expired consent granted again |

## Payload format (v2)

All webhook events use:

```json
{
  "event": "consent.given",
  "timestamp": "2026-02-12T09:10:11.000000+00:00",
  "uid": "psub_d4e5f6789012345678901234abcdef01",
  "client_id": "ck_live_123456789",
  "sources": []
}
```

`sources[]` is event-specific:

- `consent.given`:
  - `provider`, `scopes[]`, `valid_until`, `is_reauthorized`
- `consent.revoked`:
  - `provider`, `revoked_at`, `reason`
- `consent.expiring`:
  - `provider`, `valid_until`, `days_until_expiry`
- `consent.reauthorized`:
  - `provider`, `scopes[]`, `valid_until`, `is_returning_user`

## Response examples

### `consent.given`

```json
{
  "event": "consent.given",
  "timestamp": "2026-02-12T09:10:11.000000+00:00",
  "uid": "psub_d4e5f6789012345678901234abcdef01",
  "client_id": "ck_live_123456789",
  "sources": [
    {
      "provider": "google_data",
      "scopes": [
        "https://www.googleapis.com/auth/dataportability.myactivity.search",
        "https://www.googleapis.com/auth/dataportability.chrome.history"
      ],
      "valid_until": "2026-08-11T09:10:11.000000+00:00",
      "is_reauthorized": false
    },
    {
      "provider": "gmail",
      "scopes": [
        "https://www.googleapis.com/auth/gmail.readonly"
      ],
      "valid_until": "2026-08-11T09:10:11.000000+00:00",
      "is_reauthorized": false
    }
  ]
}
```

### `consent.revoked`

```json
{
  "event": "consent.revoked",
  "timestamp": "2026-02-12T09:22:44.000000+00:00",
  "uid": "psub_d4e5f6789012345678901234abcdef01",
  "client_id": "ck_live_123456789",
  "sources": [
    {
      "provider": "gmail",
      "revoked_at": "2026-02-12T09:22:44.000000+00:00",
      "reason": "user_revoked"
    }
  ]
}
```

### `consent.expiring`

```json
{
  "event": "consent.expiring",
  "timestamp": "2026-02-12T09:22:44.000000+00:00",
  "uid": "psub_d4e5f6789012345678901234abcdef01",
  "client_id": "ck_live_123456789",
  "sources": [
    {
      "provider": "google_data",
      "valid_until": "2026-02-15T09:22:44.000000+00:00",
      "days_until_expiry": 3
    }
  ]
}
```

### `consent.reauthorized`

```json
{
  "event": "consent.reauthorized",
  "timestamp": "2026-02-12T09:22:44.000000+00:00",
  "uid": "psub_d4e5f6789012345678901234abcdef01",
  "client_id": "ck_live_123456789",
  "sources": [
    {
      "provider": "google_data",
      "scopes": [
        "https://www.googleapis.com/auth/dataportability.myactivity.search"
      ],
      "valid_until": "2026-08-11T09:22:44.000000+00:00",
      "is_returning_user": true
    }
  ]
}
```

## Handling webhooks

<CodeGroup>

```typescript TypeScript
import crypto from "crypto";
import express from "express";

const app = express();
app.use(express.raw({ type: "application/json" }));

const secret = process.env.EMERGE_WEBHOOK_SECRET;
if (!secret) {
  throw new Error("Missing EMERGE_WEBHOOK_SECRET");
}

app.post("/webhooks/emerge", async (req, res) => {
  try {
    const signature = req.header("x-signature");
    const idempotencyKey = req.header("idempotency-key");

    if (!signature || !idempotencyKey) {
      return res.status(401).send("Missing signature or idempotency key");
    }

    const expected = crypto.createHmac("sha256", secret).update(req.body).digest("hex");
    const valid =
      signature.length === expected.length &&
      crypto.timingSafeEqual(Buffer.from(signature, "hex"), Buffer.from(expected, "hex"));

    if (!valid) {
      return res.status(401).send("Invalid signature");
    }

    // Idempotency guard (replace with DB/Redis in production)
    if (seen(idempotencyKey)) {
      return res.status(200).send("Duplicate ignored");
    }
    remember(idempotencyKey);

    const payload = JSON.parse(req.body.toString("utf8")) as {
      event: string;
      uid: string;
      sources: Array<Record<string, unknown>>;
    };

    if (payload.event === "consent.revoked") {
      await handleRevocation(payload.uid, payload.sources);
    }

    return res.status(200).send("OK");
  } catch (error) {
    console.error("Webhook processing failed", error);
    return res.status(500).send("Server error");
  }
});

const idempotencyStore = new Set<string>();
function seen(key: string): boolean {
  return idempotencyStore.has(key);
}
function remember(key: string): void {
  idempotencyStore.add(key);
}

async function handleRevocation(uid: string, sources: Array<Record<string, unknown>>) {
  for (const source of sources) {
    const provider = String(source.provider ?? "");
    if (provider) {
      await purgeProviderData(uid, provider);
    }
  }
}

async function purgeProviderData(uid: string, provider: string) {
  console.log(`Purging ${provider} data for ${uid}`);
}
```

```python Python
import hashlib
import hmac
import json
import os
from fastapi import FastAPI, HTTPException, Request

app = FastAPI()
secret = os.getenv("EMERGE_WEBHOOK_SECRET")
if not secret:
    raise RuntimeError("Missing EMERGE_WEBHOOK_SECRET")

_seen: set[str] = set()

@app.post("/webhooks/emerge")
async def receive_webhook(request: Request):
    body = await request.body()
    signature = request.headers.get("x-signature")
    idem_key = request.headers.get("idempotency-key")

    if not signature or not idem_key:
        raise HTTPException(status_code=401, detail="Missing signature or idempotency key")

    expected = hmac.new(secret.encode(), body, hashlib.sha256).hexdigest()
    if not hmac.compare_digest(signature, expected):
        raise HTTPException(status_code=401, detail="Invalid signature")

    if idem_key in _seen:
        return {"status": "duplicate_ignored"}
    _seen.add(idem_key)

    payload = json.loads(body)
    if payload.get("event") == "consent.revoked":
        uid = payload.get("uid", "")
        for source in payload.get("sources", []):
            provider = source.get("provider")
            if provider:
                await purge_provider_data(uid, provider)

    return {"status": "ok"}

async def purge_provider_data(uid: str, provider: str):
    print(f"Purging {provider} data for {uid}")
```

</CodeGroup>

## Delivery and retries

- A non-2xx response triggers retries with exponential backoff.
- Current max attempts: `5`.
- Always design handlers to be idempotent using `Idempotency-Key`.

## Related docs

- [Callbacks](/link/callbacks)
- [Data WalletÂ©](/data-wallet/overview)
- [Query Overview](/query/overview)
