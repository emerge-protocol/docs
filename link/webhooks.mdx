---
title: "Webhooks"
description: "Receive notifications when user data is ready"
---

Webhooks notify your application when user data is ready to query. This is more efficient than polling the export status endpoint.

## Webhook events

| Event | Description |
|-------|-------------|
| `consent.given` | User granted consent |
| `consent.revoked` | User revoked consent |
| `consent.expiring` | Consent will expire soon (7 days warning) |
| `consent.completed` | Consent flow completed successfully |
| `export.completed` | Data export finished, ready to query |
| `export.failed` | Export failed (usually insufficient data) |
| `token.needs_reauth` | OAuth token expired, user needs to reauthorize |

## Webhook payload

All webhooks follow this structure:

```json
{
  "event": "export.completed",
  "timestamp": "2024-01-15T10:35:00Z",
  "data": {
    "uid": "psub_d4e5f6789012345678901234abcdef01",
    "client_id": "your_client_id",
    "provider": "google-gmail"
  }
}
```

## Event details

### consent.given

Sent when a user grants consent for the first time.

```json
{
  "event": "consent.given",
  "timestamp": "2024-01-15T10:30:00Z",
  "data": {
    "uid": "psub_d4e5f6789012345678901234abcdef01",
    "client_id": "your_client_id",
    "provider": "google-gmail",
    "scopes": ["email.read", "profile"],
    "valid_until": "2025-01-15T10:30:00Z"
  }
}
```

### consent.revoked

Sent when a user revokes their consent (e.g., via Google account settings or your application).

```json
{
  "event": "consent.revoked",
  "timestamp": "2024-01-15T10:35:00Z",
  "data": {
    "uid": "psub_d4e5f6789012345678901234abcdef01",
    "client_id": "your_client_id",
    "provider": "google-gmail",
    "revoked_at": "2024-01-15T10:34:00Z"
  }
}
```

### consent.expiring

Sent 7 days before consent expires. Use this to prompt users to reauthorize.

```json
{
  "event": "consent.expiring",
  "timestamp": "2024-01-08T10:30:00Z",
  "data": {
    "uid": "psub_d4e5f6789012345678901234abcdef01",
    "client_id": "your_client_id",
    "provider": "google-gmail",
    "expires_at": "2024-01-15T10:30:00Z"
  }
}
```

### consent.completed

Sent when the consent flow completes successfully (user finished all steps).

```json
{
  "event": "consent.completed",
  "timestamp": "2024-01-15T10:32:00Z",
  "data": {
    "uid": "psub_d4e5f6789012345678901234abcdef01",
    "client_id": "your_client_id",
    "provider": "google-gmail",
    "is_reauthorization": false
  }
}
```

### export.completed

Sent when a user's data export is complete and ready to query.

```json
{
  "event": "export.completed",
  "timestamp": "2024-01-15T10:35:00Z",
  "data": {
    "uid": "psub_d4e5f6789012345678901234abcdef01",
    "client_id": "your_client_id",
    "provider": "google-gmail",
    "data_types": ["search", "browsing", "youtube", "ads"],
    "record_counts": {
      "search": 1523,
      "browsing": 8742,
      "youtube": 412,
      "ads": 89
    }
  }
}
```

### export.failed

Sent when an export fails, usually due to insufficient data.

```json
{
  "event": "export.failed",
  "timestamp": "2024-01-15T10:35:00Z",
  "data": {
    "uid": "psub_d4e5f6789012345678901234abcdef01",
    "client_id": "your_client_id",
    "provider": "google-gmail",
    "reason": "insufficient_data",
    "details": "Account has less than 10 emails or 3 months of history"
  }
}
```

### token.needs_reauth

Sent when the OAuth token has expired or been revoked and the user needs to reauthorize.

```json
{
  "event": "token.needs_reauth",
  "timestamp": "2024-01-15T10:35:00Z",
  "data": {
    "uid": "psub_d4e5f6789012345678901234abcdef01",
    "client_id": "your_client_id",
    "provider": "google-gmail",
    "reason": "token_expired"
  }
}
```

## Configuring webhooks

Configure your webhook endpoint in the Control Room:

1. Go to **Settings** → **Webhooks**
2. Enter your webhook URL (must be HTTPS)
3. Select events to receive
4. Save and test

Alternatively, set the `webhook_url` when configuring your flow:

```typescript
await fetch('https://link.emergedata.ai/configs', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${API_TOKEN}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    config_name: 'default',
    company_name: 'Your Company',
    // ...other config
    webhook_url: 'https://yourapp.com/webhooks/emerge'
  })
});
```

## Handling webhooks

<CodeGroup>

```typescript TypeScript
import express from 'express';
import crypto from 'crypto';

const app = express();
app.use(express.raw({ type: 'application/json' }));

const WEBHOOK_SECRET = process.env.EMERGE_WEBHOOK_SECRET!;

app.post('/webhooks/emerge', async (req, res) => {
  try {
    // 1. Verify signature (raw body)
    const signature = req.headers['x-emerge-signature'] as string | undefined;
    if (!signature) {
      return res.status(401).send('Missing signature');
    }

    const expectedSignature = crypto
      .createHmac('sha256', WEBHOOK_SECRET)
      .update(req.body)
      .digest('hex');

    if (signature !== expectedSignature) {
      console.error('Invalid webhook signature');
      return res.status(401).send('Invalid signature');
    }

    // 2. Handle event
    const payload = JSON.parse(req.body.toString('utf8'));
    const { event, data } = payload;

    switch (event) {
      case 'consent.given':
        await handleConsentGiven(data);
        break;

      case 'consent.revoked':
        await handleConsentRevoked(data);
        break;

      case 'consent.expiring':
        await handleConsentExpiring(data);
        break;

      case 'export.completed':
        await handleExportCompleted(data);
        break;

      case 'export.failed':
        await handleExportFailed(data);
        break;

      case 'token.needs_reauth':
        await handleTokenNeedsReauth(data);
        break;

      default:
        console.log(`Unknown event: ${event}`);
    }

    // 3. Acknowledge receipt
    res.status(200).send('OK');
  } catch (err) {
    console.error('Webhook error', err);
    res.status(500).send('Server error');
  }
});

async function handleConsentGiven(data: { uid: string }) {
  console.log(`Consent granted for user ${data.uid}`);
  // Update user record, prepare for data
}

async function handleConsentRevoked(data: { uid: string }) {
  console.log(`Consent revoked for user ${data.uid}`);
  // Delete user data per GDPR requirements
  await deleteUserData(data.uid);
}

async function handleConsentExpiring(data: { uid: string; expires_at: string }) {
  console.log(`Consent expiring for user ${data.uid} at ${data.expires_at}`);
  // Send reminder email to user
  await sendReauthorizationReminder(data.uid);
}

async function handleExportCompleted(data: {
  uid: string;
  data_types: string[];
  record_counts: Record<string, number>;
}) {
  console.log(`Data ready for user ${data.uid}`);
  // Trigger data processing
  await processUserData(data.uid);
}

async function handleExportFailed(data: { uid: string; reason: string }) {
  console.log(`Export failed for user ${data.uid}: ${data.reason}`);
  // Notify user
  await notifyExportFailed(data.uid, data.reason);
}

async function handleTokenNeedsReauth(data: { uid: string }) {
  console.log(`Token needs reauth for user ${data.uid}`);
  // Prompt user to reauthorize
  await sendReauthorizationRequest(data.uid);
}
```

```python Python
from fastapi import FastAPI, Request, HTTPException
import hmac
import hashlib
import json
import os

app = FastAPI()

WEBHOOK_SECRET = os.environ['EMERGE_WEBHOOK_SECRET']

@app.post('/webhooks/emerge')
async def emerge_webhook(request: Request):
    # 1. Verify signature
    signature = request.headers.get('x-emerge-signature')
    if not signature:
        raise HTTPException(status_code=401, detail='Missing signature')

    payload = await request.body()

    expected_signature = hmac.new(
        WEBHOOK_SECRET.encode(),
        payload,
        hashlib.sha256
    ).hexdigest()

    if not hmac.compare_digest(signature, expected_signature):
        raise HTTPException(status_code=401, detail='Invalid signature')

    # 2. Handle event
    body = json.loads(payload)
    event = body['event']
    data = body['data']

    if event == 'consent.given':
        await handle_consent_given(data)
    elif event == 'consent.revoked':
        await handle_consent_revoked(data)
    elif event == 'consent.expiring':
        await handle_consent_expiring(data)
    elif event == 'export.completed':
        await handle_export_completed(data)
    elif event == 'export.failed':
        await handle_export_failed(data)
    elif event == 'token.needs_reauth':
        await handle_token_needs_reauth(data)
    else:
        print(f'Unknown event: {event}')

    # 3. Acknowledge receipt
    return {'status': 'ok'}


async def handle_consent_given(data: dict):
    uid = data['uid']
    print(f'Consent granted for user {uid}')


async def handle_consent_revoked(data: dict):
    uid = data['uid']
    print(f'Consent revoked for user {uid}')
    # Delete user data per GDPR requirements
    await delete_user_data(uid)


async def handle_consent_expiring(data: dict):
    uid = data['uid']
    expires_at = data['expires_at']
    print(f'Consent expiring for user {uid} at {expires_at}')
    # Send reminder email
    await send_reauthorization_reminder(uid)


async def handle_export_completed(data: dict):
    uid = data['uid']
    print(f'Data ready for user {uid}')
    # Trigger data processing
    await process_user_data(uid)


async def handle_export_failed(data: dict):
    uid = data['uid']
    reason = data['reason']
    print(f'Export failed for user {uid}: {reason}')
    # Notify user
    await notify_export_failed(uid, reason)


async def handle_token_needs_reauth(data: dict):
    uid = data['uid']
    print(f'Token needs reauth for user {uid}')
    # Prompt user to reauthorize
    await send_reauthorization_request(uid)
```

</CodeGroup>

## Signature verification

<Warning>
Always verify the webhook signature before processing. This ensures the webhook came from Emerge and wasn't forged.
</Warning>

The signature is an HMAC-SHA256 hash of the raw request body using your webhook secret:

```typescript
const signature = crypto
  .createHmac('sha256', WEBHOOK_SECRET)
  .update(rawBody)
  .digest('hex');
```

## Best practices

<AccordionGroup>
  <Accordion title="Respond quickly">
    Return a 200 response within 5 seconds. Process webhooks asynchronously by queueing them.
  </Accordion>
  <Accordion title="Handle duplicates">
    Webhooks may be delivered multiple times. Use the `timestamp` and `uid` to deduplicate.
  </Accordion>
  <Accordion title="Implement retries">
    If your endpoint returns a non-2xx status, Emerge retries with exponential backoff (up to 3 attempts).
  </Accordion>
  <Accordion title="Log all webhooks">
    Store webhook payloads for debugging and audit purposes.
  </Accordion>
</AccordionGroup>

## Testing webhooks

Use the Control Room to send test webhooks:

1. Go to **Settings** → **Webhooks**
2. Click **Send Test**
3. Select event type
4. Verify your endpoint receives and processes the test event
